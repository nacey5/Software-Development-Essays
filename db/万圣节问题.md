# 万圣节问题

为什么叫万圣节问题呢？我刚开始以为是这种现象跟闹鬼了似的，所以叫万圣节问题。然而  

根据维基百科的描述：

在计算中，万圣节问题是指数据库中的一种现象，其中更新操作导致行的物理位置发生变化，从而可能允许稍后在同一更新操作中再次访问该行。  
在某些情况下，这甚至可能导致无限循环，其中更新不断地将更新的记录置于执行更新操作的扫描之前。
1976 年万圣节那天，Don Chamberlin、Pat Selinger和Morton Astrahan在执行一项查询时首次发现了此数据库错误的可能性，该查询本应为每个收入低于 25,000 美元的员工加薪 10%。
该查询将成功运行，没有错误，但完成后，数据库中的所有员工至少赚取了 25,000 美元，因为它不断给他们加薪，直到他们达到该水平。
我们期望查询能够对工资低于 25,000 美元的每条员工记录精确地迭代一次。
事实上，由于即使更新的记录对查询执行引擎也是可见的，因此继续匹配查询的条件，因此工资记录会多次匹配，并且每次都会加薪 10%，直到它们全部大于 25,000 美元。 
(下面是对英语原文的翻译)
帕特和莫顿在万圣节发现了这个问题......我记得他们走进我的办公室并说：“钱伯林，看看这个。我们必须确保当优化器制定处理更新的计划时，它不会使用基于正在更新的字段的索引。我们将如何做到这一点？” 碰巧是在星期五，
我们说：“听着，今天下午我们无法解决这个问题。让我们给它起一个名字。我们将其称为万圣节问题，我们将致力于解决这个问题。”下周吧。” 事实证明，从那时起它就一直被称为这个名字。

也就是如下面所示:
~~~sql
UPDATE EMP SET SALARY = SALARY*1.1 WHERE SALARY < 25000
~~~

所以会出现这种情况
~~~sql
orign data  
index name sal
1     Bob  10000
2     Tom  10500
3     Salar 26000
~~~  
更新完成之后会变成  
~~~sql
index name sal
1     Tom  10500
2     Bob  11000
3     Salar 26000
~~~
因为这样的索引序重新排列，导致会不断出现更新的情况，使得他们全部大于25000的时候才停止。  
大家有兴趣可以自己推以下，每次更新1号位和2号位会因为大小的改变而导致索引的变更。
这就是万圣节问题。   

但是目前的所有的数据库都没有这种问题了，大家都会对这些问题进行修复，但是如果你是自己去做一个数据库内核的话，这个问题也要记住哦~
